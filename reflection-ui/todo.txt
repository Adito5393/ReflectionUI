- simplify the code:
	. add DialogBuilder & ObjectDialogDuilder
	. move the whenClosingialog on caller side
	. reflection about the complexity of the code:
		* currently the parent-child link between modification stacks
		is handled by the SwingRenderer.openDialog() method. The field
		control only hands the parent modif stack to this method. It is
		not good. Normally this link must be managed by the field Control.
		The SwingRenderer only have to open the dialog and return somehow
		the opening data to the  field control that will manage this data.
		This data may be complex depending on the opening spec (OK/CANCEL
		or additional buttons, ...)
		
		
	public <T> JDialog createObjectDialog(Component activatorComponent, final Accessor<T> valueAccessor,
			final boolean isGetOnly, final String title, Image iconImage, final IInfoCollectionSettings settings,
			final ModificationStack parentModificationStack, boolean cancellable, final boolean[] okPressedHolder,
			final boolean[] changeDetectedHolder, List<Component> additionalToolbarControls) {
		final ModificationStack[] modificationStackHolder = new ModificationStack[1];

		final Object[] valueHolder = new Object[] { valueAccessor.get() };
		Runnable whenClosingDialog = new Runnable() {
			@SuppressWarnings("unchecked")
			@Override
			public void run() {
				if (changeDetectedHolder != null) {
					changeDetectedHolder[0] = isChangeDetected();
				}
				if ((okPressedHolder == null) || okPressedHolder[0]) {
					if (isChangeDetected()) {
						if (parentModificationStack != null) {
							if (modificationStackHolder[0].isInvalidated()) {
								if (!isGetOnly) {
									valueAccessor.set((T) valueHolder[0]);
								}
								parentModificationStack.invalidate();
							} else {
								parentModificationStack.beginComposite();
								if (!isGetOnly) {
									valueAccessor.set((T) valueHolder[0]);
								}
								parentModificationStack.pushUndo(modificationStackHolder[0].toCompositeModification());
								parentModificationStack.endComposite(title, UndoOrder.FIFO);
							}
						} else {
							if (!isGetOnly) {
								valueAccessor.set((T) valueHolder[0]);
							}
						}
					}
				} else {
					if (modificationStackHolder[0] != null) {
						if (!modificationStackHolder[0].isInvalidated()) {
							if (modificationStackHolder[0].getNumberOfUndoUnits() > 0) {
								modificationStackHolder[0].undoAll();
								if (changeDetectedHolder != null) {
									changeDetectedHolder[0] = false;
								}
							}
						}
					}
				}
			}

			private boolean isChangeDetected() {
				if (modificationStackHolder[0] != null) {
					return !modificationStackHolder[0].isNull();
				}
				return false;
			}
		};

		return createObjectDialog(activatorComponent, valueHolder, isGetOnly, title, iconImage, settings, cancellable,
				okPressedHolder, whenClosingDialog, additionalToolbarControls);
	}

		
		
		
- allow to hide undo management in customizations:
	. windows toolbars must be refreshable
	. add undoManagementHiden field 
- list customization item action undo not handled properly:
item does not have a modif stack. Check.
- field auto-update???
- move from ReflectionUI.java to ITypeInfo.java
	. copy methods
	. equals method
	...
- allow to sort list view
- update ScreenShots
- update Example
- Fix all the tests
- Add ctor ReflectionUI(TypeInfoProxyGenerator... proxyGenerators)
- add concept IFieldInfo.isValueCopy()
- Cannot insert sub item into MultipleFieldAsList item
- MultipleFieldAsList with only 1 item???
- ListControl does not filter item fields
- undo/redo bug (testable with TreeTableModelExample)
- delete class ABstractTreeStructuralInfo
- add IFieldControl.handlesModificationStackUpdate()
	. if true then the form delgetes ModificationStack 
	update entirely to (the control
- list control:
	. hide edit button when useless???
- customizations edition:
	. sort lists (fileds, methods, columns, ...)
	. filter lists: remove renamed or deleted targets
	. remove adequately list control buttons (move, delete, ...)  
- preset customizations object names must be special 
	. ex: prefixe with '.': Field ".position" or ".type"
- add class MetodSignature
- openDialog() must be getOnly for immutable types
- add Customizations:
	. lists:
		* onlyToString value
		* columns order
		* override item type???
		* add type column
		* change tree column
	. field:
		* override type???
- add Customizations:
	. list column order
	. constructors (hide, ...)
	. methods default param values
- ReflectionUIUtils.onTypeInstanciation()
must not use SwingRenderer
- hideNullableConf must disappear: 
the metadata editor will allow to specify how to handle and display 
null values 
- type infos must not contains any specific GUI code. Ex: remove
	. ITypeInfo.createFieldControl()
	. ITypeInfo.getIcon()
	. IFieldInfo.getIcon()
	. *.getIcon()
- For null field, allow custom instanciation
- There are debugging issues with type proxies: a type proxy is designed
to work with a specific kind of object. The stack of proxies can be so 
important that when it mismatches the object instance it becomes
difficult to find where the bug is. The solution would be to be able to
check the compatibility between the proxy type and the object. Some
proxies have the same compatibility as their underlying type making it 
more difficult to know the actual compatibility. Actually the 
compatibility check is already done by the supports() method. But this 
method is barely invoked. It may help to call it systematically in the
base proxy configuration or to add an information in all the proxies
that visually indicates the object compatibility. 
   

/*
 * public boolean openValueDialog(...): This method must allow to edit a
 * value, report the new value and the detailed value modifications.
 * Value modifications are needed because there may not be any new
 * object but rather an old object with its internal fields modified.
 * Due to the opacity of methods invocation impacts, the modifications
 * may not be well reported. If so, in the doubt the value must be
 * considered as new. To allow that methods must report "UNKNOWN"
 * modifications.
 */


/*
 * Issue: field value read only is not the same as field value
 * sub-fields read only. If the field is read only then it must be
 * reflected when the field value is wrapped. If the field is not
 * wrapped then there is no need to reflect any read only feature in the
 * form. It must be rather reflected in the bottom buttons: read only
 * implies no OK button. But if it is so, then there is no way to create 
 read only viewers when needed, for instance to display Exceptions. But
 why would it be necessary for exception dialog to be read only, more
 over if the developers explicitly allowed to modify them. But it would
 anyway be interesting to have the possibility to build read only viewers.    
 * 
 */
		

- openObjectDialog() cannot detect changes of objects with only methods.
Change should be detected each time a rw method is invoked???
even if we o not know how to revert it
- guessing rules are too complicated to understand by 
developers. Maybe they should be moved to editable metadatas.
- metatada wysiwyg editor???
- it is impossible for custom field controls to prevent 
modfications of non-primitive values because readonly field
does not imply ICollectionSettings.allreadOnly for the field 
value  
- colors should never be set on components,
otherwise lookandfeel dynamic change is not taken into account.
See:
	. TextControl
	. listControl.treeControl
- menus???
- listControl: 
	. deatil view
- update translatable strings
- private => protected
- new controls:
	. spinner, slider for numbers
	. dateChooser
	. colorChooser
